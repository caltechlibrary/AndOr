<!DOCTYPE html>
<html>
<head>
    <title>Caltech Library's Digital Library Development Sandbox</title><link rel="stylesheet" href="/css/site.css">
</head>
<body>
<header><a href="https://library.caltech.edu"><img src="/assets/liblogo.gif" alt="Caltech Library logo"></a>
</header>
<nav>
<ul>
<li><a href="/">Home</a></li>
<li><a href="./">README</a></li>
<li><a href="license.html">LICENSE</a></li>
<li><a href="install.html">INSTALL</a></li>
<li><a href="./docs">Documentation</a></li>
<li><a href="https://github.com/caltechlibrary/AndOr">Github</a>
<!-- + [Releases](https://github.com/caltechlibrary/AndOr/releases/) --></li>
</ul>

</nav>

<section>
<h1 id="and-or">And/Or</h1>

<blockquote>
<p><span class="red">An</span>other <span class="red">d</span>igital / <span class="red">O</span>bject <span class="red">r</span>epository</p>
</blockquote>

<p>This is a concept document for a very light weight digital object
repository implemented as &quot;a multi-user version of
<a href="https://caltechlibrary.github.io/dataset">dataset</a> with a web
based GUI&quot;. It targets the ability to curate
metadata objects and attachments outside the scope of
our existing repositories.</p>

<p><strong>And/Or</strong> is based on <a href="https://caltechlibrary.github.io/dataset">dataset</a>.
It is a JSON API plus HTML, CSS and JavaScript to provide a web
GUI interface for curating objects.  A minimum running system
would consist of only two or three pieces of software. The minimum
would be a web server<sup class="footnote-ref" id="fnref:1"><a href="#fn:1">1</a></sup> plus the <strong>And/Or</strong> service supporting
multi-user interaction with dataset collections.  Depending on size
you could create a micro service providing search via Python and
Lunr<sup class="footnote-ref" id="fnref:2"><a href="#fn:2">2</a></sup> or generate Lunrjs indexes to run browser side.  This
arrangement has the advantage of limiting development of new
code to be written to the <strong>And/Or</strong> web service plus the HTML,
CSS and JavaScript needed for an acceptable UI<sup class="footnote-ref" id="fnref:3"><a href="#fn:3">3</a></sup>.</p>

<p>This particular architecture aligns with small machine hosting
and cloud hosting keeping recurring costs to a minimum.
In the cloud it should work on a small to medium EC2 instance.
A more elaborate version could be implemented using Cloud Front,
S3, and running the API service in an AWS container.
In house hosting could as light weight as Raspberry Pi 4 or
as elaborate as a server with attached NAS<sup class="footnote-ref" id="fnref:4"><a href="#fn:4">4</a></sup>.</p>

<h2 id="goals">Goals</h2>

<ul>
<li>Provide a curatorial platform for metadata outside our existing repositories</li>
<li>Provide an <strong>interim option</strong> for EPrints repositories requiring migration</li>
<li>Thin stack

<ul>
<li>No RDMS requirement (only And/Or and a web server)</li>
<li>Be easier than migrating our EPrints</li>
<li>Be faster than EPrints under load</li>
<li>Be simpler than EPrints, Invenio, Drupal/Islandora</li>
</ul></li>
<li>Use existing schema</li>
<li>Support role based workflows</li>
<li>Support versioned attached media files</li>
<li>Support continuous migration</li>
<li>Support alternative front ends (e.g. Drupal)</li>
</ul>

<h2 id="project-assumptions">Project Assumptions</h2>

<ul>
<li><a href="https://github.com/caltechlibrary/dataset">dataset</a> collections are sufficient to hold metadata and media</li>
<li>UI can be implemented using HTML 5 elements, minimal JavaScript and CSS</li>
<li>Small number of curatorial users, larger number of readers</li>
<li>Configurable roles are a requirement

<ul>
<li>roles describe capabilities (permissions)</li>
<li>roles describe one or more work queues</li>
<li>queues are an object state</li>
</ul></li>
<li>Use existing object scheme (e.g. EPrints XML in Oral Histories)</li>
<li>Authentication is external (e.g. Basic Auth, JWT, Shibboleth, OAuth 2)</li>
<li>Search and query are handle independent of API

<ul>
<li>e.g. Lunr either browser or server side</li>
</ul></li>
</ul>

<h2 id="limiting-features-and-complexity">Limiting features and complexity</h2>

<p>Some of the most complicated parts of digital object repositories
are managing customization, managing users, manage roles,
manage permissions and enforcing storage scheme.  <strong>And/Or</strong>'s
simplification involves either avoiding the requirements or relocating
them to an appropriate external system.</p>

<p>Examples--</p>

<ul>
<li>Authentication is handle externally. That means we don't need to create UI to manage passwords, the volatile and sensitive data is outside of <strong>And/Or</strong></li>
<li><strong>And/Or</strong> itself is a simple web API that accepts URL requests
and hands back JSON. The shape of the JSON is determined at time of
migrating into <strong>And/Or</strong>. There is no customization.  If you want to change your data shapes you write a script to do that or change your input form.</li>
<li>If you need additional end points beyond what <strong>And/Or</strong> provides (e.g. a search engine service) you supply those as micro services behind the same web server</li>
</ul>

<p>The web browser itself creates the illusion of a unified software system
or single process. A single application is not required to support desire
functionality. Customization then can be deferred to other micro services
or even external systems (e.g. looking up something at datacite.org or
orcid.org).</p>

<p>Some features are unavoidable. The repository problem requires managing
users and roles. It doesn't require users and roles
be manage through the web. Setting up users and roles can be
managed through simpler command line tools and configuration files.
The is reasonable in large part because you've off loaded
identify management already.</p>

<p>By focusing on a minimal feature set and leveraging technical
opportunities that already exist we can radically
reduce the lines of code written and maintained.</p>

<h3 id="end-points-for-our-api-map-to-dataset-operations">End points for our API map to dataset operations</h3>

<ul>
<li><code>/COLLECTION_NAME/keys/</code> (GET) to list objects keys</li>
<li><code>/COLLECTION_NAME/create/OBJECT_ID</code> (GET) to provide an Object's creates a new object, OBJECT_ID must be unique to succeed</li>
<li><code>/COLLECTION_NAME/read/OBJECT_IDS</code> (GET) if single object_id return record otherwise a list of objects is returned</li>
<li><code>/COLLECTION_NAME/update/OBJECT_ID</code> (POST) to update an object</li>
<li><code>/COLLECTION_NAME/delete/OBJECT_ID</code> (POST) to delete an object</li>
</ul>

<p>&quot;keys&quot; can be filtered by role's queue name. Paging can be implemented
client side by segmenting the key list returned.
All other end points are static resources (e.g. HTML files,
CSS, JavaScript and Lunrjs indexes, a public faces website).<br>
We can reducing our requirements to two end points because
we've discovered that is all we needed based on our work
with <a href="https://www.eprints.org" title="A repository system developed at University of South Hampton">EPrints</a>. Everything else can be synthesized
from a simple key list and object access.</p>

<h3 id="building-a-ui">Building a UI</h3>

<p>Five pages would need to be designed and implemented in HTML, CSS and
JavaScript for our proof of concept.</p>

<ol>
<li>Login and landing page</li>
<li>Display List records (filterable by work queue)</li>
<li>Display Object details</li>
<li>Create/edit Object details</li>
<li>Search UI</li>
</ol>

<p>For public facing content (e.g. things Google, Bing, et el.
should find and index) can be deployed separately by
process similar to how feeds.library.caltech.edu works.
This also keeps <strong>And/Or</strong> simple with fewer requirements.</p>

<h3 id="user-plus-role-a-simple-model">user plus role, a simple model</h3>

<p>An authenticated user exposes their user id to
<strong>And/Or</strong>'s web service (e.g. via a JSON Web Token or
Basic Auth header).  A user's id maps to membership in roles.
The role defines access to queues, queues are list objects
with a matching value of <code>._Queue</code>.</p>

<p>Unauthenticated users are treated as the &quot;anonymous&quot; user and
are restricted by roles available for the &quot;anonymous&quot; user.
This is how you could implement both dark and public
repositories.</p>

<p>Complicated use cases like electronic thesis deposits
or faculty self deposit of articles could be implemented as
separate specialized micro services that interact with
<strong>And/Or</strong> via proxy service accounts.</p>

<h3 id="under-the-hood">Under the hood</h3>

<p><strong>And/Or</strong> is built on <a href="https://caltechlibrary.github.io/dataset">dataset</a>.
Objects may include attached documents which can be versioned
automatically. If metadata versioning becomes required dataset
can be extended to store diffs as well as the JSON documents.</p>

<p>Like EPrints <strong>And/Or</strong> does not directly support deleting objects.
Instead it can create the illusion of deleting objects by putting
objects into a &quot;deleted&quot; queue which you can exclude from your
roles or garbage collection through a separate process.</p>

<h2 id="additional-ideas">Additional ideas</h2>

<ul>
<li>Use cases

<ul>
<li><a href="docs/Role-Use-Cases.html">Users, Roles and Queues</a></li>
</ul></li>
<li>Concept proofs

<ul>
<li><a href="docs/people-groups.html">People and Groups</a></li>
<li><a href="docs/migrating-eprints.html">Migrating an EPrints Repository</a></li>
<li><a href="Oral-Histories-as-Proof-of-Concept.html">Oral Histories</a></li>
</ul></li>
<li>Scheme walk through

<ul>
<li><a href="docs/User-Scheme.html">User Scheme</a></li>
<li><a href="docs/Role-Scheme.html">Role Scheme</a></li>
<li><a href="docs/Queue-Scheme.html">Queue Scheme</a></li>
<li><a href="docs/Object-Scheme.html">Object Scheme</a></li>
</ul></li>
</ul>
<h1 id="footnote-section">Footnotes</h1>

<div class="footnotes">

<hr>

<ol>
<li id="fn:1">NginX and Apache provide authentication mechanisms such as Basic AUTH, Shibboleth and OAuth 2.</li>

<li id="fn:2"><a href="https://lunrjs.com">Lunr</a> is a browser friendly indexing and search library that can now be supported server side too via Python.</li>

<li id="fn:3">UI, user interface, the normal way a user interacts with a website</li>

<li id="fn:4">NAS, network attached storage similar to what are now common in research labs</li>
</ol>

</div>

</section>

<footer>
<span><h1><A href="https://caltech.edu">Caltech</a></h1></span>
<span>&copy; 2019 <a href="https://www.library.caltech.edu/copyright">Caltech library</a></span>
<address>1200 E California Blvd, Mail Code 1-32, Pasadena, CA 91125-3200</address> 
<span>Phone: <a href="tel:+1-626-395-3405">(626)395-3405</a></span>
<span><a href="mailto:library@caltech.edu">Email Us</a></span>
<a class="cl-hide" href="sitemap.xml">Site Map</a>
</footer>
<!-- START: PrettyFi from https://github.com/google/code-prettify -->
<script>
/* We want to add the class "prettyprint" to all the pre elements */
var pre_list = document.querySelectorAll("pre");

pre_list.forEach(function(elem) {
    elem.classList.add("prettyprint");
    elem.classList.add("linenums");/**/
    elem.classList.add("json"); /**/
});
</script>
<style>
li.L0, li.L1, li.L2, li.L3, li.L4, li.L5, li.L6, li.L7, li.L8, li.L9
{
    color: #555;
    list-style-type: decimal;
}
</style>
<link rel="stylesheet" type="text/css" href="/css/prettify.css">
<script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js"></script>
<!--  END: PrettyFi from https://github.com/google/code-prettify -->
</body>
</html>
